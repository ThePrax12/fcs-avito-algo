Идея Rabin-Karp
Вместо сравнения подстрок посимвольно считаем их хеш. Хеш можно быстро обновлять при сдвиге
окна на 1 символ. Если хеш окна совпал с хешем pattern, то дополнительно
проверяем равенство подстрок, чтобы избежать ошибок из-за коллизий.

В задаче берётся полиномиальный хеш
mod — большое простое число
base — основание

Хеш строки s длины m:
H(s) = (sum_{k=0..m-1} ord(s[k]) * base^(m-1-k) ) % mod

Тогда зная H(w_i), где w_i = text[i : i+m], мы легко получим H(w_{i+1}) за O(1).
P = base^(m-1) % mod
H_pre = ( H(w_i) - ord(text[i]) * P ) % mod
H(w_{i+1}) = ( H_pre * base + ord(text[i+m]) ) % mod

Если H(w_i) == H(pattern), то делаем проверку:
text[i : i+m] == pattern. Это поможет избежать коллизий.



Сложность:
хеш pattern: O(m)
хеш первого окна: O(m)
n-m сдвигов, каждый O(1): O(n-m)
Итого: O(n + m).

Дополнительные проверки подстрок выполняются только при совпадении хеша.
Среднее время обычно близко к O(n + m).
Худший случай (много совпадений хеша): O(n * m).

Память:
O(1) дополнительной памяти. Gлюс O(k) на список ответов, где k — число вхождений.
